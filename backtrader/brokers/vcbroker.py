#!/usr/bin/env python
"""VC Chart Broker Module - VisualChart broker implementation.

This module provides the VCBroker for trading through VisualChart
platform.

Classes:
    VCCommInfo: Commission info for VisualChart.
    VCBroker: Broker implementation for VisualChart trading.

Example:
    >>> store = bt.stores.VCStore()
    >>> cerebro.setbroker(store.getbroker())
"""

import collections
import threading
from datetime import date, datetime, timedelta

from backtrader.brokerbase import BrokerBase
from backtrader.comminfo import CommInfoBase
from backtrader.order import BuyOrder, Order, SellOrder
from backtrader.parameters import ParameterDescriptor
from backtrader.position import Position
from backtrader.stores import vcstore

from ..parameters import StringParam


class VCCommInfo(CommInfoBase):
    """
    Commissions are calculated by ib, but the trade calculations in the
    ```Strategy`` rely on the order carrying a CommInfo object attached for the
    calculation of the operation cost and value.

    These are non-critical information, but removing them from the trade could
    break existing usage, and it is better to provide a CommInfo objet which
    enables those calculations even if with approvimate values.

    The margin calculation is not known in advance information with IB
    (margin impact can be gotten from OrderState objects), and therefore it is
    left as a future exercise to get it"""

    def getvaluesize(self, size, price):
        """Calculate the value size for margin calculation.

        Args:
            size: Position size.
            price: Price of the instrument.

        Returns:
            float: The margin requirement (approaches price in real life).
        """
        # In real life, the margin approaches the price
        return abs(size) * price

    def getoperationcost(self, size, price):
        """Returns the necessary amount of cash an operation would cost"""
        # Same reasoning as above
        return abs(size) * price


# Registration mechanism, automatically register broker class when module is imported
def _register_vc_broker_class(broker_cls):
    """Register broker class with the store when module is loaded"""
    vcstore.VCStore.BrokerCls = broker_cls
    return broker_cls


@_register_vc_broker_class
class VCBroker(BrokerBase):
    """Broker implementation for VisualChart.

    This class maps the orders/positions from VisualChart to the
    internal API of `backtrader`.

    Params:

      - ``account`` (default: None)

        VisualChart supports several accounts simultaneously on the broker. If
        the default ``None`` is in place, the first account in the ComTrader
        ``Accounts`` collection will be used.

        If an account name is provided, the Accounts collection will be
        checked and used if present

      - ``commission`` (default: None)

        An object will be autogenerated if no commission-scheme is passed as
        parameter

        See the notes below for further explanations

    Notes:

      - Position

        VisualChart reports "OpenPositions" updates through the ComTrader
        interface but only when the position has a "size". An update to
        indicate a position has moved to ZERO is reported by the absence of
        such a position. This forces to keep accounting of the positions by
        looking at the execution events, just like the simulation broker does

      - Commission

        The ComTrader interface of VisualChart does not report commissions, and
        as such, the auto-generated CommissionInfo object cannot use
        non-existent commissions to properly account for them. In order to
        support commissions, a commission parameter has to be passed with
        the appropriate commission schemes.

        The documentation on Commission Schemes details how to do this

      - Expiration Timing

        The ComTrader interface (or is it the comtypes module?) discards
        ``time`` information from ``datetime`` objects and expiration dates are
        always full dates.

      - Expiration Reporting

        At the moment, no heuristic is in place to determine when a canceled
        order has been canceled due to expiration. And therefore, expired
        orders are reported as canceled.
    """

    # Parameter descriptor definition
    account = StringParam(default="", doc="Account name")
    commission = ParameterDescriptor(
        default=lambda: CommInfoBase(percabs=True),
        doc="Default commission scheme which applies to all assets",
    )

    def __init__(self, **kwargs):
        """Initialize the VCBroker.

        Sets up the store, account data, position accounting, order storage,
        and order type/side/restriction mappings for VisualChart integration.

        Args:
            **kwargs: Keyword arguments passed to parent and store initialization.
        """
        super().__init__(**kwargs)

        self.store = vcstore.VCStore(**kwargs)

        # Account data
        self._acc_name = None
        self.startingcash = self.cash = 0.0
        self.startingvalue = self.value = 0.0

        # Position accounting
        self._lock_pos = threading.Lock()  # sync account updates
        self.positions = collections.defaultdict(Position)  # actual positions

        # Order storage
        self._lock_orders = threading.Lock()  # control access
        self.orderbyid = dict()  # orders by order id

        # Notifications
        self.notifs = collections.deque()

        # Dictionaries of values for order mapping
        self._otypes = {
            Order.Market: self.store.vcctmod.OT_Market,
            Order.Close: self.store.vcctmod.OT_Market,
            Order.Limit: self.store.vcctmod.OT_Limit,
            Order.Stop: self.store.vcctmod.OT_StopMarket,
            Order.StopLimit: self.store.vcctmod.OT_StopLimit,
        }

        self._osides = {
            Order.Buy: self.store.vcctmod.OS_Buy,
            Order.Sell: self.store.vcctmod.OS_Sell,
        }

        self._otrestriction = {
            Order.T_None: self.store.vcctmod.TR_NoRestriction,
            Order.T_Date: self.store.vcctmod.TR_Date,
            Order.T_Close: self.store.vcctmod.TR_CloseAuction,
            Order.T_Day: self.store.vcctmod.TR_Session,
        }

        self._ovrestriction = {
            Order.V_None: self.store.vcctmod.VR_NoRestriction,
        }

        self._futlikes = (
            self.store.vcdsmod.IT_Future,
            self.store.vcdsmod.IT_Option,
            self.store.vcdsmod.IT_Fund,
        )

    def start(self):
        """Start the broker and its store.

        Calls parent start method and initializes the VisualChart store
        with this broker instance.
        """
        super().start()
        self.store.start(broker=self)

    def stop(self):
        """Stop the broker and its store.

        Calls parent stop method and stops the VisualChart store.
        """
        super().stop()
        self.store.stop()

    def getcash(self):
        """Get the current cash balance.

        Returns:
            float: Current available cash in the account.

        Note:
            This call is non-blocking and returns the cached cash value.
        """
        # This call cannot block if no answer is available from ib
        return self.cash

    def getvalue(self, datas=None):
        """Get the current portfolio value.

        Args:
            datas: Unused parameter (for API compatibility).

        Returns:
            float: Current net worth (portfolio value) of the account.
        """
        return self.value

    def get_notification(self):
        """Get the next order notification from the queue.

        Returns:
            Order: The next notification order object (at least a None is present).

        Raises:
            IndexError: If notification queue is empty.
        """
        return self.notifs.popleft()  # at leat a None is present

    def notify(self, order):
        """Add an order notification to the queue.

        Args:
            order: The order to notify (will be cloned before queuing).
        """
        self.notifs.append(order.clone())

    def next(self):
        """Mark the notification boundary for the current iteration.

        Appends None to mark the end of notifications for this iteration.
        """
        self.notifs.append(None)  # mark notificatino boundary

    def getposition(self, data, clone=True):
        """Get the current position for a data feed.

        Args:
            data: The data feed object.
            clone: If True, return a clone of the position (default: True).

        Returns:
            Position: The position object (cloned if clone=True).
        """
        with self._lock_pos:
            pos = self.positions[data._tradename]
            if clone:
                return pos.clone()

        return pos

    def getcommissioninfo(self, data):
        """Get the commission info object for a data feed.

        Args:
            data: The data feed object.

        Returns:
            CommInfoBase: The commission info object for the data feed.
        """
        if data._tradename in self.comminfo:
            return self.comminfo[data._tradename]

        comminfo = self.comminfo[None]
        if comminfo is not None:
            return comminfo

        stocklike = data._syminfo.Type in self._futlikes

        return VCCommInfo(mult=data._syminfo.PointValue, stocklike=stocklike)

    def _makeorder(
        self,
        ordtype,
        owner,
        data,
        size,
        price=None,
        plimit=None,
        exectype=None,
        valid=None,
        tradeid=0,
        **kwargs,
    ):
        """Create a VisualChart order object from backtrader parameters.

        Args:
            ordtype: Order type (Buy or Sell).
            owner: The owner of the order (typically a strategy).
            data: The data feed for the order.
            size: Order size (positive for buy, negative for sell internally).
            price: Order price (for Limit/Stop orders).
            plimit: Limit price (for StopLimit orders).
            exectype: Execution type (Market, Limit, Stop, StopLimit, Close).
            valid: Order validity (None, date, or timedelta).
            tradeid: Trade identifier.
            **kwargs: Additional VisualChart-specific order parameters.

        Returns:
            Order: A VisualChart Order object.
        """
        order = self.store.vcctmod.Order()
        order.Account = self._acc_name
        order.SymbolCode = data._tradename
        order.OrderType = self._otypes[exectype]
        order.OrderSide = self._osides[ordtype]

        order.VolumeRestriction = self._ovrestriction[Order.V_None]
        order.HideVolume = 0
        order.MinVolume = 0

        # order.UserName = 'danjrod'  # str(tradeid)
        # order.OrderId = 'a' * 50  # str(tradeid)
        order.UserOrderId = ""
        if tradeid:
            order.ExtendedInfo = f"TradeId {tradeid}"
        else:
            order.ExtendedInfo = ""

        order.Volume = abs(size)

        order.StopPrice = 0.0
        order.Price = 0.0
        if exectype == Order.Market:
            pass
        elif exectype == Order.Limit:
            order.Price = price or plimit  # cover naming confusion cases
        elif exectype == Order.Close:
            pass
        elif exectype == Order.Stop:
            order.StopPrice = price
        elif exectype == Order.StopLimit:
            order.StopPrice = price
            order.Price = plimit

        order.ValidDate = None
        if exectype == Order.Close:
            order.TimeRestriction = self._otrestriction[Order.T_Close]
        else:
            if valid is None:
                order.TimeRestriction = self._otrestriction[Order.T_None]
            elif isinstance(valid, (datetime, date)):
                order.TimeRestriction = self._otrestriction[Order.T_Date]
                order.ValidDate = valid
            elif isinstance(valid, (timedelta,)):
                if valid == Order.DAY:
                    order.TimeRestriction = self._otrestriction[Order.T_Day]
                else:
                    order.TimeRestriction = self._otrestriction[Order.T_Date]
                    order.ValidDate = datetime.now() + valid

            elif not self.valid:  # DAY
                order.TimeRestriction = self._otrestriction[Order.T_Day]

        # Support for custom user arguments
        for k in kwargs:
            if hasattr(order, k):
                setattr(order, k, kwargs[k])

        return order

    def submit(self, order, vcorder):
        """Submit an order to VisualChart.

        Args:
            order: The backtrader order object.
            vcorder: The VisualChart order object.

        Returns:
            Order: The submitted order with assigned VisualChart order ID.
        """
        order.submit(self)

        vco = vcorder
        oid = self.store.vcct.SendOrder(
            vco.Account,
            vco.SymbolCode,
            vco.OrderType,
            vco.OrderSide,
            vco.Volume,
            vco.Price,
            vco.StopPrice,
            vco.VolumeRestriction,
            vco.TimeRestriction,
            ValidDate=vco.ValidDate,
        )

        order.vcorder = oid
        order.addcomminfo(self.getcommissioninfo(order.data))

        with self._lock_orders:
            self.orderbyid[oid] = order
        self.notify(order)
        return order

    def buy(
        self,
        owner,
        data,
        size,
        price=None,
        plimit=None,
        exectype=None,
        valid=None,
        tradeid=0,
        **kwargs,
    ):
        """Create and submit a buy order.

        Args:
            owner: The owner of the order (typically a strategy).
            data: The data feed for the order.
            size: Order size (must be positive).
            price: Order price (for Limit/Stop orders).
            plimit: Limit price (for StopLimit orders).
            exectype: Execution type (Market, Limit, Stop, StopLimit, Close).
            valid: Order validity (None, date, or timedelta).
            tradeid: Trade identifier.
            **kwargs: Additional VisualChart-specific order parameters.

        Returns:
            Order: The submitted buy order.
        """
        order = BuyOrder(
            owner=owner,
            data=data,
            size=size,
            price=price,
            pricelimit=plimit,
            exectype=exectype,
            valid=valid,
            tradeid=tradeid,
        )

        order.addinfo(**kwargs)

        vcorder = self._makeorder(
            order.ordtype, owner, data, size, price, plimit, exectype, valid, tradeid, **kwargs
        )

        return self.submit(order, vcorder)

    def sell(
        self,
        owner,
        data,
        size,
        price=None,
        plimit=None,
        exectype=None,
        valid=None,
        tradeid=0,
        **kwargs,
    ):
        """Create and submit a sell order.

        Args:
            owner: The owner of the order (typically a strategy).
            data: The data feed for the order.
            size: Order size (must be positive).
            price: Order price (for Limit/Stop orders).
            plimit: Limit price (for StopLimit orders).
            exectype: Execution type (Market, Limit, Stop, StopLimit, Close).
            valid: Order validity (None, date, or timedelta).
            tradeid: Trade identifier.
            **kwargs: Additional VisualChart-specific order parameters.

        Returns:
            Order: The submitted sell order.
        """
        order = SellOrder(
            owner=owner,
            data=data,
            size=size,
            price=price,
            pricelimit=plimit,
            exectype=exectype,
            valid=valid,
            tradeid=tradeid,
        )

        order.addinfo(**kwargs)

        vcorder = self._makeorder(
            order.ordtype, owner, data, size, price, plimit, exectype, valid, tradeid, **kwargs
        )

        return self.submit(order, vcorder)

    #
    # COM Events implementation
    #
    def __call__(self, trader):
        """Initialize the broker with the VisualChart trader object.

        This is called when the broker is invoked by the store to set up
        the trader connection and account information.

        Args:
            trader: The VisualChart trader object from COM interface.

        Returns:
            VCBroker: Self, for method chaining.
        """
        # Called to start the process, call in sub-thread. only the passed
        # trader can be used in the thread
        self.trader = trader

        for acc in trader.Accounts:
            if self.p.account is None or self.p.account == acc.Account:
                self.startingcash = self.cash = acc.Balance.Cash
                self.startingvalue = self.value = acc.Balance.NetWorth
                self._acc_name = acc.Account
                break  # found the account

        return self

    def OnChangedBalance(self, Account):
        """Handle balance change event from VisualChart.

        Args:
            Account: Account name that experienced the balance change.
        """
        if self._acc_name is None or self._acc_name != Account:
            return  # skip notifs for other accounts

        for acc in self.trader.Accounts:
            if acc.Account == Account:
                # Update store values
                self.cash = acc.Balance.Cash
                self.value = acc.Balance.NetWorth
                break

    def OnModifiedOrder(self, Order):
        """Handle order modification event from VisualChart.

        Note:
            This is currently not implemented as backtrader does not
            support order modification.

        Args:
            Order: The VisualChart order object that was modified.
        """
        # We are not expecting this: unless backtrader starts implementing
        # modify order method
        pass

    def OnCancelledOrder(self, Order):
        """Handle order cancellation event from VisualChart.

        Args:
            Order: The VisualChart order object that was cancelled.
        """
        with self._lock_orders:
            try:
                border = self.orderbyid[Order.OrderId]
            except KeyError:
                return  # possibly external order

        border.cancel()
        self.notify(border)

    def OnTotalExecutedOrder(self, Order):
        """Handle total order execution event from VisualChart.

        Args:
            Order: The VisualChart order object that was fully executed.
        """
        self.OnExecutedOrder(Order, partial=False)

    def OnPartialExecutedOrder(self, Order):
        """Handle partial order execution event from VisualChart.

        Args:
            Order: The VisualChart order object that was partially executed.
        """
        self.OnExecutedOrder(Order, partial=True)

    def OnExecutedOrder(self, Order, partial):
        """Handle order execution event from VisualChart.

        Updates position, calculates PnL, and notifies strategy.

        Args:
            Order: The VisualChart order object that was executed.
            partial: Whether this was a partial execution (True) or full (False).
        """
        with self._lock_orders:
            try:
                border = self.orderbyid[Order.OrderId]
            except KeyError:
                return  # possibly external order

        price = Order.Price
        size = Order.Volume
        if border.issell():
            size *= -1

        # Find position and do a real update - accounting happens here
        position = self.getposition(border.data, clone=False)
        pprice_orig = position.price
        psize, pprice, opened, closed = position.update(size, price)

        comminfo = border.comminfo
        closedvalue = comminfo.getoperationcost(closed, pprice_orig)
        closedcomm = comminfo.getcommission(closed, price)

        openedvalue = comminfo.getoperationcost(opened, price)
        openedcomm = comminfo.getcommission(opened, price)

        pnl = comminfo.profitandloss(-closed, pprice_orig, price)
        margin = comminfo.getvaluesize(size, price)

        # NOTE: No commission information available in the Trader interface
        # CHECK: Use reported time instead of last data time?
        border.execute(
            border.data.datetime[0],
            size,
            price,
            closed,
            closedvalue,
            closedcomm,
            opened,
            openedvalue,
            openedcomm,
            margin,
            pnl,
            psize,
            pprice,
        )  # pnl

        if partial:
            border.partial()
        else:
            border.completed()

        self.notify(border)

    def OnOrderInMarket(self, Order):
        """Handle order accepted in market event from VisualChart.

        Args:
            Order: The VisualChart order object that was accepted.
        """
        # Other is in the market... therefore "accepted"
        with self._lock_orders:
            try:
                border = self.orderbyid[Order.OrderId]
            except KeyError:
                return  # possibly external order

        border.accept()
        self.notify(border)

    def OnNewOrderLocation(self, Order):
        """Handle new order location event from VisualChart.

        Note:
            This could be used for "submitted" status, but the status
            is currently set manually.

        Args:
            Order: The VisualChart order object.
        """
        # Can be used for "submitted", but the status is set manually
        pass

    def OnChangedOpenPositions(self, Account):
        """Handle open positions change event from VisualChart.

        Note:
            This is not used for accounting as VisualChart does not report
            positions moving back to zero. Accounting is handled through
            order execution events instead.

        Args:
            Account: Account name that experienced the position change.
        """
        # This would be useful if it reported a position moving back to 0. In
        # this case, the report contains a no-position and this doesn't help in
        # the accounting. That's why the accounting is delegated to the
        # reception of order execution
        pass

    def OnNewClosedOperations(self, Account):
        """Handle new closed operations event from VisualChart.

        Note:
            This callback has not been observed in practice.

        Args:
            Account: Account name with new closed operations.
        """
        # This call-back has not been seen
        pass

    def OnServerShutDown(self):
        """Handle server shutdown event from VisualChart.

        This is called when the VisualChart server shuts down.
        """
        pass

    def OnInternalEvent(self, p1, p2, p3):
        """Handle internal event from VisualChart.

        Args:
            p1: Event parameter 1.
            p2: Event parameter 2.
            p3: Event parameter 3.
        """
        pass
