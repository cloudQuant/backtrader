# 迭代115 - 移除残余元编程技术

## 背景

项目已成功移除了元类(`metaclass=`)的使用，但仍保留了多种元编程技术。这些技术增加了代码复杂度，降低了可读性和可维护性，也为未来C++重构带来障碍。本迭代目标是系统性地移除或简化这些残余的元编程技术。

## 当前元编程使用现状

### 1. `sys._getframe()` 调用栈检查 (8处) - **高优先级**

| 文件 | 函数/位置 | 用途 | 风险等级 |
|------|----------|------|---------|
| `metabase.py:291` | `findowner()` | 查找对象所有者(Strategy/Cerebro) | 高 |
| `lineiterator.py:456` | `dopostinit()` | 指标在推导式中查找Strategy owner | 高 |
| `linebuffer.py:1552` | `LineActions.__init__()` | 查找策略对象 | 中 |
| `feed.py:256` | `_find_feed_owner()` | FeedBase实例查找 | 中 |

**问题分析**：
- `sys._getframe()` 是CPython实现细节，PyPy等实现不支持
- 栈帧检查性能差，每次调用需遍历调用栈
- 代码耦合度高，难以理解和调试
- C++重构时无法直接移植

**根因**：框架采用隐式owner关系，依赖运行时栈帧推断，而非显式参数传递。

### 2. `__new__` 方法重写 (14处) - **中优先级**

| 文件 | 类 | 代码行数 | 用途 |
|------|-----|---------|------|
| `lineiterator.py` | `LineIterator` | ~80行 | 对象创建、数据处理、lines初始化 |
| `lineiterator.py` | `StrategyBase` | ~10行 | 策略数据设置 |
| `strategy.py` | `Strategy` | ~70行 | 方法重命名、参数处理 |
| `strategy.py` | `SignalStrategy` | ~20行 | next方法重映射 |
| `lineseries.py` | `LineSeries` | ~20行 | lines类实例化 |
| `linebuffer.py` | `LineActions` | ~50行 | 数据处理 |
| `analyzer.py` | `Analyzer` | ~30行 | 分析器创建 |
| `observer.py` | `Observer` | ~30行 | 观察器创建 |
| `store.py` | `Store` | ~20行 | 单例模式 |
| `mixins/singleton.py` | `Singleton*` | ~40行 | 单例实现 |
| `metabase.py` | `AutoInfoClass` | ~20行 | 参数初始化 |
| `metabase.py` | `ParamsBase` | ~30行 | 参数初始化 |

**问题分析**：
- `__new__` 与 `__init__` 职责不清晰
- 大量逻辑在 `__new__` 中执行，违反Python惯例
- kwargs在 `__new__` 和 `__init__` 间传递复杂
- 继承时行为难以预测

### 3. `eval()` 动态代码执行 (5处) - **高优先级(安全)**

| 文件 | 行号 | 代码示例 | 风险 |
|------|------|---------|------|
| `btrun/btrun.py:124` | `eval("dict(" + cer_kwargs_str + ")")` | 解析cerebro参数 | 代码注入 |
| `btrun/btrun.py:179` | `eval("dict(" + wrkwargs_str + ")")` | 解析writer参数 | 代码注入 |
| `btrun/btrun.py:206` | `eval("dict(" + args.plot + ")")` | 解析plot参数 | 代码注入 |
| `btrun/btrun.py:533` | `eval(kwtext)` | 解析模块kwargs | 代码注入 |
| `btrun/btrun.py:599` | `eval(kwtext)` | 解析函数kwargs | 代码注入 |

**问题分析**：
- `eval()` 执行任意Python代码，存在严重安全风险
- 命令行输入直接传入 `eval()`，可被恶意利用
- 影响代码审计和安全认证

### 4. `__getattribute__` / `__setattr__` 重写 (84处) - **中优先级**

**主要分布**：
- `lineseries.py` (36处) - LineSeries属性访问代理
- `parameters.py` (10处) - 参数代理
- `metabase.py` (9处) - 基类属性处理

**问题分析**：
- 每次属性访问都触发复杂逻辑
- 多层代理导致性能损耗
- 调试困难，IDE代码补全失效
- 继承时行为复杂

### 5. `__init_subclass__` 钩子 (16处) - **低优先级(推荐保留)**

| 文件 | 类 | 用途 |
|------|-----|------|
| `lineseries.py` | `LineSeriesMixin` | lines类创建 |
| `lineiterator.py` | `LineIteratorMixin` | 子类初始化 |
| `indicator.py` | `Indicator` | 指标注册 |
| `parameters.py` | `ParamsMixin` | 参数描述符设置 |

**评估**：`__init_subclass__` 是Python 3.6+推荐的子类定制机制，**建议保留**。

### 6. 描述符协议 (14处) - **低优先级(推荐保留)**

| 文件 | 类 | 用途 |
|------|-----|------|
| `lineseries.py` | `LineAlias` | 线条别名访问 |
| `parameters.py` | `ParamDescriptor` | 参数访问代理 |

**评估**：描述符是Python推荐的属性定制机制，**建议保留**。

---

## 任务清单

### Phase 1: 高优先级 - 安全和可移植性 (预计2-3天)

#### 任务1.1: 移除 `eval()` 使用
**目标**：使用安全的参数解析替代 `eval()`

**修改文件**：`backtrader/btrun/btrun.py`

**方案**：
```python
# 方案A: 使用 ast.literal_eval (推荐)
import ast

def safe_parse_kwargs(kwtext: str) -> dict:
    """安全解析kwargs字符串"""
    try:
        # 尝试literal_eval (只支持字面量)
        return ast.literal_eval(f"dict({kwtext})")
    except (ValueError, SyntaxError):
        # 回退到逐项解析
        return _parse_kwargs_manually(kwtext)

def _parse_kwargs_manually(kwtext: str) -> dict:
    """手动解析key=value格式"""
    result = {}
    for item in kwtext.split(','):
        if '=' in item:
            key, value = item.split('=', 1)
            key = key.strip()
            value = value.strip()
            # 尝试转换类型
            result[key] = _convert_value(value)
    return result

def _convert_value(value: str):
    """转换字符串值为适当类型"""
    # 布尔值
    if value.lower() in ('true', 'false'):
        return value.lower() == 'true'
    # 整数
    try:
        return int(value)
    except ValueError:
        pass
    # 浮点数
    try:
        return float(value)
    except ValueError:
        pass
    # 字符串 (去除引号)
    if (value.startswith('"') and value.endswith('"')) or \
       (value.startswith("'") and value.endswith("'")):
        return value[1:-1]
    return value
```

**验收标准**：
- [ ] 所有5处 `eval()` 被替换
- [ ] `btrun` 命令行功能正常
- [ ] 回归测试通过

---

#### 任务1.2: 重构 `findowner()` 函数
**目标**：使用显式参数传递替代栈帧检查

**修改文件**：
- `backtrader/metabase.py`
- `backtrader/lineiterator.py`
- `backtrader/linebuffer.py`
- `backtrader/feed.py`

**方案**：

```python
# 方案: 上下文管理器 + 线程局部存储
import threading
from contextlib import contextmanager

# 线程局部存储当前上下文
_context = threading.local()

class OwnerContext:
    """Owner上下文管理"""
    
    @staticmethod
    def get_current_owner():
        """获取当前owner"""
        stack = getattr(_context, 'owner_stack', [])
        return stack[-1] if stack else None
    
    @staticmethod
    @contextmanager
    def set_owner(owner):
        """设置当前owner上下文"""
        if not hasattr(_context, 'owner_stack'):
            _context.owner_stack = []
        _context.owner_stack.append(owner)
        try:
            yield
        finally:
            _context.owner_stack.pop()

# 使用示例 - Strategy中创建指标
class Strategy:
    def __init__(self):
        with OwnerContext.set_owner(self):
            # 在此上下文中创建的所有指标自动关联到self
            self.sma = SMA(self.data, period=20)
            
# 指标中获取owner
class Indicator:
    def __init__(self, data, **kwargs):
        # 优先使用显式参数，否则从上下文获取
        self._owner = kwargs.pop('_owner', None) or OwnerContext.get_current_owner()
```

**修改点**：

1. **metabase.py**：
   - 保留 `findowner()` 函数签名，内部改用上下文查找
   - 添加 `OwnerContext` 类

2. **lineiterator.py**：
   - `LineIterator.__new__` 中移除栈帧检查
   - 在 `dopostinit` 中使用 `OwnerContext.get_current_owner()`

3. **Strategy.__init__**：
   - 使用 `with OwnerContext.set_owner(self):` 包裹指标创建

4. **linebuffer.py / feed.py**：
   - 移除 `sys._getframe` 调用
   - 使用上下文获取owner

**验收标准**：
- [ ] 所有8处 `sys._getframe` 被移除
- [ ] 指标在推导式中创建正常工作
- [ ] 回归测试通过 (330个测试)

---

### Phase 2: 中优先级 - 简化 `__new__` (预计3-4天)

#### 任务2.1: 简化 `LineIterator.__new__`
**目标**：将逻辑迁移到 `__init__`

**当前问题**：
```python
# LineIterator.__new__ 当前做了太多事情:
# 1. 创建实例
# 2. 存储kwargs到实例
# 3. 初始化_lineiterators
# 4. 查找owner
# 5. 初始化lines
# 6. 设置lines._owner_ref
```

**方案**：
```python
class LineIterator(LineIteratorMixin, LineSeries):
    def __new__(cls, *args, **kwargs):
        """仅创建实例，不做额外处理"""
        return super().__new__(cls)
    
    def __init__(self, *args, **kwargs):
        """所有初始化逻辑移到这里"""
        # 1. 初始化基础属性
        self._lineiterators = collections.defaultdict(list)
        
        # 2. 获取owner (从上下文或参数)
        self._owner = kwargs.pop('_owner', None) or OwnerContext.get_current_owner()
        
        # 3. 初始化lines
        self._init_lines()
        
        # 4. 调用父类初始化
        super().__init__(*args, **kwargs)
        
        # 5. 注册到owner
        self._register_with_owner()
```

#### 任务2.2: 简化 `Strategy.__new__`
**目标**：将方法重命名移到 `__init_subclass__`

```python
class Strategy(StrategyBase):
    def __init_subclass__(cls, **kwargs):
        super().__init_subclass__(**kwargs)
        
        # 方法重命名 (仅执行一次，在类定义时)
        if hasattr(cls, 'notify') and not hasattr(cls, 'notify_order'):
            cls.notify_order = cls.notify
            delattr(cls, 'notify')
        if hasattr(cls, 'notify_operation') and not hasattr(cls, 'notify_trade'):
            cls.notify_trade = cls.notify_operation
            delattr(cls, 'notify_operation')
    
    def __new__(cls, *args, **kwargs):
        """仅创建实例"""
        return super().__new__(cls)
    
    def __init__(self, *args, **kwargs):
        """参数处理移到这里"""
        self._setup_params(kwargs)
        super().__init__(*args, **kwargs)
```

#### 任务2.3: 简化其他 `__new__` 方法
- `Analyzer.__new__` → 移到 `__init__`
- `Observer.__new__` → 移到 `__init__`
- `LineSeries.__new__` → 移到 `__init__`
- `LineActions.__new__` → 移到 `__init__`

**验收标准**：
- [ ] `__new__` 方法仅包含实例创建
- [ ] 所有初始化逻辑在 `__init__` 中
- [ ] kwargs传递简化
- [ ] 回归测试通过

---

### Phase 3: 中优先级 - 简化属性代理 (预计2天)

#### 任务3.1: 简化 `LineSeries.__getattribute__`

**当前问题**：
- 700+行代码，过于复杂
- 多层代理和缓存逻辑交织
- 性能影响

**方案**：使用 `__getattr__` 替代部分 `__getattribute__`

```python
class LineSeries:
    # 移除__getattribute__重写，改用__getattr__
    
    def __getattr__(self, name):
        """仅处理未找到的属性"""
        # 1. 检查lines
        if hasattr(self, 'lines') and hasattr(self.lines, name):
            return getattr(self.lines, name)
        
        # 2. 检查datas
        if name.startswith('data') and name[4:].isdigit():
            idx = int(name[4:])
            if hasattr(self, 'datas') and idx < len(self.datas):
                return self.datas[idx]
        
        raise AttributeError(f"'{type(self).__name__}' has no attribute '{name}'")
```

#### 任务3.2: 简化 `LineSeries.__setattr__`

**方案**：减少特殊处理，使用标准属性设置

```python
class LineSeries:
    _INTERNAL_ATTRS = {'_owner', '_owner_ref', '_clock', 'lines', 'datas', ...}
    
    def __setattr__(self, name, value):
        """简化的属性设置"""
        if name.startswith('_') or name in self._INTERNAL_ATTRS:
            object.__setattr__(self, name, value)
        else:
            # 检查是否是line绑定
            if self._try_bind_line(name, value):
                return
            object.__setattr__(self, name, value)
```

**验收标准**：
- [ ] `__getattribute__` 代码减少50%+
- [ ] 属性访问性能提升
- [ ] 回归测试通过

---

## 测试计划

### 单元测试
```bash
# 运行所有测试
pytest tests/ -v

# 运行特定测试
pytest tests/add_tests/test_lineiterator_*.py -v
pytest tests/add_tests/test_strategy_*.py -v
```

### 性能测试
```python
# 测试属性访问性能
import timeit

def test_getattr_performance():
    indicator = SMA(data, period=20)
    
    # 测试line访问
    t1 = timeit.timeit(lambda: indicator.lines[0], number=100000)
    t2 = timeit.timeit(lambda: indicator.line, number=100000)
    
    print(f"lines[0]: {t1:.3f}s, line: {t2:.3f}s")
```

### 回归测试
- 确保所有330个测试用例通过
- 特别关注指标计算、策略执行、数据处理

---

## 风险评估

| 风险 | 可能性 | 影响 | 缓解措施 |
|-----|-------|-----|---------|
| 指标在推导式中创建失败 | 中 | 高 | 上下文管理器方案，保留fallback |
| 属性访问行为变化 | 中 | 中 | 充分测试，渐进式修改 |
| 性能下降 | 低 | 中 | 性能基准测试，按需优化 |
| 向后兼容性问题 | 中 | 高 | 保留旧API，标记deprecated |

---

## 时间估算

| Phase | 任务 | 预计时间 |
|-------|-----|---------|
| Phase 1 | 移除eval() | 0.5天 |
| Phase 1 | 重构findowner() | 1.5天 |
| Phase 2 | 简化__new__方法 | 3天 |
| Phase 3 | 简化属性代理 | 2天 |
| 测试&修复 | 回归测试和bug修复 | 2天 |
| **总计** | | **9天** |

---

## 验收标准

1. **代码质量**：
   - [x] 移除所有 `sys._getframe()` 调用 ✅ 已完成
   - [x] 移除所有 `eval()` 调用 ✅ 已完成 (使用ast.literal_eval替代)
   - [x] `__new__` 方法简化 ✅ 部分完成 (Analyzer/Observer已移除，核心类保留)
   - [x] 代码可读性显著提升 ✅

2. **功能完整**：
   - [x] 所有478个测试用例通过 ✅
   - [x] 指标在各种场景下正常工作 ✅
   - [x] 策略执行正确 ✅

3. **性能**：
   - [x] 属性访问性能不低于当前版本 ✅
   - [x] 回测性能不低于当前版本 ✅

4. **文档**：
   - [x] 更新架构文档 ✅
   - [x] 记录API变化 ✅

---

## 完成情况记录 (2026-01-11)

### Phase 1: 高优先级 - 已完成 ✅

| 任务 | 状态 | 修改文件 |
|-----|------|---------|
| 移除eval() | ✅ | `btrun/btrun.py` - 使用`ast.literal_eval`替代 |
| 移除sys._getframe | ✅ | `metabase.py`, `lineiterator.py`, `feed.py`, `linebuffer.py` |
| Analyzer子对象OwnerContext | ✅ | `calmar.py`, `sharpe.py`, `periodstats.py`, `vwr.py`, `pyfolio.py` |

### Phase 2: 简化__new__ - 部分完成

| 类 | 状态 | 说明 |
|---|------|-----|
| `Store.__new__` | 保留 | 单例模式必需 |
| `Analyzer.__new__` | ✅ 已移除 | 逻辑移到`__init__` |
| `Observer.__new__` | ✅ 已移除 | 逻辑移到`__init__` |
| `LineSeries.__new__` | 保留 | lines实例化必需在`__init__`前 |
| `LineActions.__new__` | 保留 | 核心初始化逻辑 |
| `LineIterator.__new__` | 保留 | kwargs存储、lines实例化必需 |
| `Strategy.__new__` | 保留 | 方法重命名、核心初始化 |

### Phase 3: 简化属性代理 - 评估后暂缓

`__getattribute__`/`__setattr__`重写涉及核心数据访问机制，修改风险高，暂不处理。

### 测试结果

```
478/478 测试通过 ✅
```

---

## 附录：元编程位置详细清单

### sys._getframe 使用位置
```
metabase.py:291       - findowner()函数
lineiterator.py:436   - dopostinit()中的注释
lineiterator.py:440   - dopostinit()中的注释  
lineiterator.py:452   - dopostinit()中的注释
lineiterator.py:456   - dopostinit()中实际调用
linebuffer.py:1552    - LineActions.__init__()
feed.py:256           - _find_feed_owner()
```

### __new__ 方法位置
```
lineiterator.py:629   - LineIterator.__new__
lineiterator.py:1975  - StrategyBase.__new__
strategy.py:135       - Strategy.__new__
strategy.py:2185      - SignalStrategy.__new__
lineseries.py:1045    - LineSeries.__new__
linebuffer.py:1329    - LineActions.__new__
analyzer.py:108       - Analyzer.__new__
observer.py:57        - Observer.__new__
store.py:34           - Store.__new__
mixins/singleton.py:47,114 - Singleton类
metabase.py:623,1393  - AutoInfoClass, ParamsBase
utils/py3.py:173      - with_metaclass辅助
```

### eval() 使用位置
```
btrun/btrun.py:124    - cerebro参数解析
btrun/btrun.py:179    - writer参数解析
btrun/btrun.py:206    - plot参数解析
btrun/btrun.py:533    - 模块kwargs解析
btrun/btrun.py:599    - 函数kwargs解析
```
