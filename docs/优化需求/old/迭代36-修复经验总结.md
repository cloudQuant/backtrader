# 迭代36 - Data Replay 修复经验总结

## 问题描述

测试用例 `test_58_data_replay.py` 在 origin 分支失败，原因是 `replaydata` 功能（将日线数据回放为周线数据）的行为与 master 分支不一致。

### 症状
- **期望值**: `final_value=108263.90`, `buy_count=13`, `sell_count=12`
- **实际值**: `final_value=107605.40`, `buy_count=3`, `sell_count=2`

交易次数显著减少，导致最终组合价值不同。

## 根因分析

通过对比 master 和 origin 分支的日志，发现问题出在 replay 模式下指标的更新方式：

### 问题1: SMA指标缓存问题

在 replay 模式下，同一个 bar 会被多次更新（例如周线的每一天都会触发更新）。但 SMA 指标使用了缓存机制，导致在同一个 bar 位置多次调用时返回缓存的旧值，而不是基于最新数据重新计算。

**位置**: `backtrader/indicators/sma.py`

**修复前**:
```python
cache_key = f"sma_{period}_{len(self.data)}"
if cache_key in self._result_cache:
    return self._result_cache[cache_key]  # 返回缓存值，但在replay模式下这是错误的
```

**修复后**:
```python
# 添加 replay 模式检测
self._last_data_len = 0  # 在 __init__ 中初始化

# 在计算方法中
current_data_len = len(self.data) if hasattr(self.data, '__len__') else 0
is_replay_update = (current_data_len == self._last_data_len and current_data_len > 0)

# 在 replay 更新时跳过缓存
if not is_replay_update and cache_key in self._result_cache:
    return self._result_cache[cache_key]
```

### 问题2: CrossOver指标状态跟踪问题

CrossOver 指标使用 `_last_nzd` 变量跟踪上一次的非零差值。在 replay 模式下，这个值会在每次中间更新时被覆盖，导致无法正确检测到交叉信号。

**位置**: `backtrader/indicators/crossover.py`

**修复前**:
```python
def next(self):
    diff = self.data0[0] - self.data1[0]
    prev_nzd = self._last_nzd if self._last_nzd is not None else diff
    self._last_nzd = diff if diff != 0.0 else prev_nzd
    # ... crossover calculation
```

**修复后**:
```python
def next(self):
    diff = self.data0[0] - self.data1[0]

    # CRITICAL FIX: 使用行索引获取前一个已完成bar的差值
    # 而不是使用缓存的 _last_nzd（在 replay 模式下会被中间更新覆盖）
    try:
        prev_diff = self.data0[-1] - self.data1[-1]
        if prev_diff == 0.0:
            prev_nzd = self._last_nzd if self._last_nzd is not None else diff
        else:
            prev_nzd = prev_diff
    except (IndexError, TypeError):
        prev_nzd = self._last_nzd if self._last_nzd is not None else diff

    self._last_nzd = diff if diff != 0.0 else prev_nzd
    # ... crossover calculation
```

## 修复原理

### Replay 模式的工作原理

当使用 `cerebro.replaydata()` 时：
1. 日线数据被逐条读取
2. 每条日线数据都会触发策略的 `next()` 方法
3. 但数据的 `len()` 只在周线完成时才增加
4. 在周内的每一天，数据的 OHLC 值会更新，但位置保持不变

### 关键洞察

1. **检测 replay 更新**: 通过比较 `len(self.data)` 与上次调用时的值，如果相同说明是 replay 模式的中间更新
2. **使用行索引**: `self.data0[-1]` 在 replay 模式下返回的是**上一个已完成周线**的值，这是正确的比较基准

## 测试验证

修复后运行测试：
```bash
python -m pytest tests/strategies/test_58_data_replay.py -v
```

结果：
- `bar_num`: 439 ✓
- `buy_count`: 13 ✓
- `sell_count`: 12 ✓
- `final_value`: 108263.90 ✓
- 测试通过 ✓

## 经验教训

1. **缓存需要考虑 replay 模式**: 任何使用缓存的指标都需要检测 replay 模式并在必要时跳过缓存
2. **状态跟踪需要使用行索引**: 在 replay 模式下，应该使用 `self.data[-1]` 获取前一个已完成 bar 的值，而不是依赖内部状态变量
3. **调试技巧**: 通过添加 `data_len` 和其他诊断信息的打印语句，可以快速定位 replay 模式下的异常行为

## 相关文件

- `/backtrader/indicators/sma.py` - SMA 指标修复
- `/backtrader/indicators/crossover.py` - CrossOver 指标修复
- `/tests/strategies/test_58_data_replay.py` - 测试用例
