# 迭代124 - 性能优化实施方案（第五轮）

## 背景

根据 `docs/opts/优化需求/迭代119-优化性能.md` 的要求：

- 使用 `python scripts/profile_performance.py`（默认参数）分析性能
- 对比 `logs/performance_profile_master_*.log`（基准） 与 `logs/performance_profile_development_*.log`（当前）
- 不允许修改测试用例；修改后需 `pip install -U .`、`bash scripts/optimize_code.sh` 并确保测试通过

迭代122/123 已完成两类关键优化：

- PandasData：`PandasData._load` 通过 Numpy 缓存减少 pandas indexer 热路径
- datetime 链路：通过 `LineBuffer.datetime()` 的缓存（按 idx/value/tz）显著减少 `num2date` 重复转换

本迭代（124）目标是在保持行为不变的前提下，继续压缩 Line 系统的核心热路径开销，重点聚焦：

- `LineBuffer.__getitem__/__setitem__/forward`（每根 bar 必经）
- `LineSeries.__setattr__`（超高频）
- `LineIterator.__len__`（调用次数和 cumtime 都很高）
- 参数系统 `ParameterManager.get`/`ParamsBase.get_param`（与 master 相比显著增多）

## 资源与对比口径

- 基准（master）：`logs/performance_profile_master_20260117_093200.log`（Total Execution Time: `563.25s`）
- 当前（development）：`logs/performance_profile_development_20260117_115132.log`（Total Execution Time: `362.85s`）
- 对比报告：
  - `logs/performance_compare_master_093200_vs_dev_115132.md`
  - `logs/performance_compare_105735_vs_115132.md`（同分支不同时间点对比）

备注：`115132.log` 的 Git Commit 字段为 `b991e92`，这是 profile 生成时的代码快照。后续若继续优化，需要在每次修改后重新运行 profile 以确保日志与提交一致。

## 现状结论（基于 115132 日志）

### 1) 总体性能

- 相比 master 基准：`563.25s -> 362.85s`（-35.6%）
- 相比 development 之前基线 `105735`：`398.67s -> 362.85s`（-9.0%）

### 2) 当前 Top Hotspots（按 tottime）

来自 `logs/performance_profile_development_20260117_115132.log`：

- `backtrader/linebuffer.py:604(forward)`
  - `10,730,236` calls, `tottime 16.25s`
- `backtrader/lineseries.py:1344(__setattr__)`
  - `21,271,573` calls, `tottime 14.92s`
- `backtrader/linebuffer.py:340(__getitem__)`
  - `19,049,698` calls, `tottime 12.04s`
- `backtrader/linebuffer.py:453(__setitem__)`
  - `10,677,205` calls, `tottime 8.51s`

同时 `builtins.getattr/hasattr/len` 也占用较多，但优先优化我们可控的 Backtrader 代码路径。

### 3) `num2date` 已显著下降，但仍是可见热点

- `dateintern.py:339(num2date)`
  - `2,227,017` calls, `tottime 7.08s`

这说明 datetime 缓存确实有效（对比 105735，`num2date` 调用下降 51.4%），但现在更主要的瓶颈已回到 Line 核心读写路径。

### 4) 与 master 相比「显著变差」的方向：参数系统与 has/get

来自 `logs/performance_compare_master_093200_vs_dev_115132.md`：

- `parameters.py:283(get)` 调用次数 `+200%`，时间 `+5.94s`
- `builtins.hasattr` 调用次数 `+49.9%`，时间 `+6.14s`
- `dict.get` 调用次数 `+99.8%`，时间 `+2.02s`

这意味着下一轮优化应考虑：

- 减少参数访问路径上的重复 dict 查找
- 在核心热路径中尽量避免 `hasattr/getattr`（可用 `__dict__.get` 或实例字段缓存替代）

## 优化方案（迭代124）

### Step 1：优化 `ParameterManager.get` 的字典访问模式（低风险，中收益）

目标：降低 `parameters.py:283(get)` 的开销。

现状问题：

- 代码使用 `if name in dict: return dict[name]` 触发两次哈希查找
- 多次 `in` 判断 + 索引访问叠加，使得在 2,894 万次量级调用下成本可观

建议改法：

- 使用 `dict.get(name, sentinel)` 方式一次查找完成，命中即返回
- 对 `_values`、`_value_cache`、`_descriptors` 都采用相同策略

验收指标：

- `parameters.py:283(get)` 的 `tottime/cumtime` 下降
- `dict.get` / `builtins.getattr/hasattr` 的调用趋势不再上升

### Step 2：优化 `ParamsBase.get_param`（或等价入口）减少 `object.__getattribute__` 和层层调用（中风险，中收益）

现状：

- `parameters.py:1368(get_param)` 出现在 Top 50（`7,405,665` calls, `tottime 3.46s`）

建议方向：

- 如果 `_param_manager` 始终存在且存储在 `__dict__`，可考虑使用 `self.__dict__.get("_param_manager")` 获取引用，减少 `object.__getattribute__`
- 或缓存 `pm = self._param_manager` / `pm_get = pm.get`（在对象生命周期内稳定时）

验收指标：

- `parameters.py:1368(get_param)` 的 `tottime/cumtime` 下降

### Step 3：优化 `LineIterator.__len__`（高收益，需谨慎回归）

现状：

- `lineiterator.py:1586(__len__)` 在 Section 1 cumtime 前列：
  - `4,082,882` calls, `cumtime 11.28s`
- 当前实现包含大量 `hasattr/try/except`、字符串判断等，适合做“缓存 + 快速路径”

建议改法：

- 初始化或首次调用时缓存 `first_line = self.lines.lines[0]` 到实例字段
- 快速路径直接 `return first_line.lencount`
- 保留极少量 fallback（异常时返回 0），避免大段嵌套逻辑

验收指标：

- `lineiterator.py:1586(__len__)` 的 `tottime/cumtime` 明显下降
- `builtins.hasattr` 调用次数下降

### Step 4：继续压缩 LineBuffer 热路径中的 `getattr/hasattr`（中风险，中收益）

目标函数：

- `linebuffer.py:340(__getitem__)`
- `linebuffer.py:453(__setitem__)`

建议方向：

- 将 `getattr(self, "_is_data_feed_line", False)` / `getattr(self, "_is_indicator", False)` 改为 `self.__dict__.get(...)`
- 对 `array`、`lencount`、`_idx` 等高频字段尽量使用局部变量缓存

验收指标：

- `linebuffer.py:340(__getitem__)`、`linebuffer.py:453(__setitem__)` 的 tottime 下降
- 内置 `getattr/hasattr` 调用次数下降趋势

### Step 5（可选）：评估 `LineSeries.__setattr__` 的热点拆分与调用来源（高风险，建议先做测量）

现状：

- `lineseries.py:1344(__setattr__)` 是最难啃的热点之一（`21M` calls, `tottime 14.92s`）

建议：

- 先定位主要调用来源（可能来自 line/indicator 绑定、owner 设置、lineiterators 维护）
- 在不改变行为的前提下：
  - 对最常见路径做更短的 fast path
  - 仅在确认为 line/indicator 对象时才进入 slow path（避免多层 try/except）

该步骤不建议直接动刀，应先用更精确的 profile（或在热点路径中加计数器）锁定贡献最大的分支。

## 验收标准（Definition of Done）

- 安装：`pip install -U .` 成功
- 格式化/质量：`bash scripts/optimize_code.sh` 通过
- 测试：`pytest tests -n 8` 全通过（不允许改测试）
- 性能复测（默认参数）：
  - 运行 `python scripts/profile_performance.py` 生成新日志
  - 与优化前 development 最新基线对比：`Total Execution Time` 不得回退（建议目标：至少 -2%）
  - 重点热点应出现下降趋势：
    - `linebuffer.py:604(forward)`
    - `linebuffer.py:340(__getitem__)`
    - `linebuffer.py:453(__setitem__)`
    - `lineseries.py:1344(__setattr__)`
    - `lineiterator.py:1586(__len__)`
    - `parameters.py:283(get)` / `parameters.py:1368(get_param)`

## 回滚方案

- 每个 Step 独立提交、独立验证
- 如出现行为差异/测试失败/性能回退：
  - 逐步 `git revert` 最近的 Step 提交
  - 确保回到上一份性能基线日志可复现的状态
