# 迭代1: 需规文档 - 修复跨平台排序不一致问题

## 1. 技术方案

### 1.1 问题定位

| 位置 | 代码 | 问题 | 修复方案 |
|------|------|------|----------|
| 第202行 | `df.groupby("symbol")` | 迭代顺序不确定 | 添加`sort=True`确保排序 |
| 第408-410行 | `rank(method="first")` | 依赖数据出现顺序 | 改用`method="average"`或先排序 |
| 第416行 | `sort_values(by=["total_score"])` | 相同score排序不稳定 | 添加次要排序键 |
| 第391行 | `for asset in self.stock_dict` | 字典遍历顺序 | 使用`sorted(self.stock_dict)` |

### 1.2 详细修复方案

#### 方案A: 修改测试用例使其确定性（推荐）

**修改1: clean_data()函数**
```python
# 原代码
for symbol, data in df.groupby("symbol"):

# 修改为
for symbol, data in df.groupby("symbol", sort=True):
```

**修改2: get_target_symbol()函数 - rank方法**
```python
# 原代码
df["close_score"] = df["close"].rank(method="first")
df["rate_score"] = df["rate"].rank(method="first")

# 修改为：使用"average"方法，并添加data_name作为tie-breaker
df["close_score"] = df["close"].rank(method="average")
df["rate_score"] = df["rate"].rank(method="average")
```

**修改3: get_target_symbol()函数 - sort_values**
```python
# 原代码
df = df.sort_values(by=["total_score"], ascending=False)

# 修改为：添加data_name作为次要排序键
df = df.sort_values(by=["total_score", "data_name"], ascending=[False, True])
```

**修改4: get_target_symbol()函数 - 字典遍历**
```python
# 原代码
for asset in self.stock_dict:

# 修改为
for asset in sorted(self.stock_dict):
```

### 1.3 预期效果

修复后，无论在Mac还是Ubuntu上：
1. 数据按symbol名称字典序加载
2. 排名使用平均方法，避免依赖输入顺序
3. 排序使用data_name作为tie-breaker，确保稳定
4. 字典遍历按排序顺序

## 2. 测试验证

### 2.1 验证步骤
1. 在Ubuntu上运行修复后的测试
2. 对比Mac和Ubuntu的输出日志
3. 确保关键指标完全一致

### 2.2 断言调整
修复后，两个平台的结果应该一致。需要确定最终使用哪个平台的预期值：
- 建议使用修复后的结果作为新的预期值
- 需要在两个平台验证后更新断言

## 3. 影响分析

### 3.1 行为变化
- 排序逻辑更确定性，可能与原Mac结果略有不同
- 但策略的核心逻辑（双低选股）不变

### 3.2 风险评估
- 低风险：修改仅影响排序稳定性，不影响策略核心逻辑
- 回测结果可能略有变化，需要更新断言值
